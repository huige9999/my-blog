
# 标题候选

用 Worktree 把本地并行开发变简单

---

# 文章结构（推荐）

## 1. 痛点：Agent 在跑，我却想并行干别的

你这段可以写得很具体，读者一下就懂：

* 我经常让 Claude Code 在当前分支上跑长任务：重构、批量改动、生成代码、跑测试……
* 任务执行过程中我突然想插入另一个小任务（修 bug / 看日志 / 改配置 / 做实验）
* 但我**不敢切分支**：

  * 切分支会影响 agent 当前的工作目录状态
  * 可能导致它正在读写的文件发生变化
  * 人也容易搞混：到底哪个分支改了什么

一句总结钉住痛点：

> **“我需要并行，但我不想打断当前进行中的工作。”**

---

## 2. 我考虑过的 4 条路：各自的成本

这一节写“抉择”特别抓人，因为它是认知迁移（别人也会踩同样的坑）。

### 选项 1：记住 worktree 命令（纯手动）

优点：

* 通用、可控、不会依赖插件
  缺点：
* 需要记/熟练一套命令
* 新手容易删错路径或搞出“幽灵 worktree”
  你可以写一句很真实的话：

> “命令不多，但我就是不想把工作记忆留给 Git 的参数。”

### 选项 2：封装 Prompt（一次性把流程写死）

优点：

* agent 全自动：创建→开发→提交→合并→清理
  缺点：
* Prompt 需要维护、要写护栏，稍微啰嗦
* 不同项目脚本/测试命令不同，Prompt 也会变复杂

### 选项 3：VS Code 插件（UI 管理）

优点：

* 低门槛、直观
  缺点：
* 多一个依赖；不同机器/远程环境未必有
* 你最终还是得理解一点原理，才能放心让它做 destructive 操作

### 选项 4（最终）：理解原理 + 用自然语言让 agent 小步执行

你这个“最终决定”非常有亮点：不是记命令，也不是写大 Prompt，而是**把命令记忆外包给 agent**，你只保留“原则和验收”。

一句概括很漂亮：

> **“我不记命令，我只记模型：worktree 是什么、它会影响什么、如何验证。”**

---

## 3. Worktree 原理：它到底解决了什么问题？

这部分建议用“心智模型 + 极简命令示意”，别写成 git 教科书。

### 3.1 一个仓库，多份工作目录

* `.git` 对象数据库只一份（提交历史、对象都共享）
* 但你可以有多个 working directory
* 每个 working directory 绑定一个分支（更精确说是绑定一个 HEAD/branch）

可以这样写：

> “Worktree 的魔法是：共享历史，隔离工作现场。”

### 3.2 为什么它适合并行开发？

* 主目录的 agent/长任务继续跑
* 新任务在新目录里，文件互不干扰
* 不需要在同一个目录里来回 switch branch

### 3.3 三条重要规则（写清楚就够）

1. 同一个分支不能被两个 worktree 同时检出
2. 删除 worktree 不会删除分支（安全设计）
3. `worktree remove` 比 `rm -rf` 更安全；必要时 `worktree prune` 清残留

---

## 4. 我的最终工作流：自然语言驱动的“小步执行”

这节是你的“可复制实践”。核心是：**你只下达意图，agent 输出命令，你执行或让它执行。每步可验证。**

你可以用类似这样的段落：

### 4.1 创建一个新 worktree（我只说目标）

我对 agent 说：

> 帮我创建一个 worktree：分支 `master_temp`，目录 `../joymew-screen_temp`。

agent 输出并执行（或我执行）：

```bash
git worktree add -b master_temp ../joymew-screen_temp
git worktree list
```

然后我做事：

* `cd ../joymew-screen_temp`
* 在新目录启动另一个 Claude Code
* 并行开发

### 4.2 做完之后清理（也是自然语言）

我对 agent 说：

> 删除 worktree `../joymew-screen_temp`，并删掉分支 `master_temp`（我确认没改动）。

它会走：

```bash
git worktree remove ../joymew-screen_temp
git branch -D master_temp
git worktree list
```

你可以强调“我最看重的不是自动化，而是可控”：

> “我不追求一条指令做完所有事，我追求每一步都有回滚/验证点。”

---

## 5. 我学到的：把“记忆”从人脑迁移到“验证”

这一节可以写得有点哲学味（但别太飘）：

* 以前：我试图记住命令（知识在我脑子里）
* 现在：我只记住原理 + 验证方法（知识在模型里）
* agent 是“操作员”，我做“验收员”
* 最小化上下文切换：并行开发时不再担心切分支打断任务

一句收尾很好：

> “真正省脑子的不是少打几个字，而是少做不可逆的决策。”

---

# 你可以直接用的一段“原理介绍”示例（可复制进博客）

> Git worktree 允许同一个 Git 仓库同时拥有多个工作目录。它们共享同一份 `.git` 对象数据库（提交历史、对象都只存一份），但每个 worktree 有各自独立的工作区文件和 HEAD 指向。
> 这意味着你可以把正在执行长任务的工作现场固定在主目录不动，同时在另一个目录里检出另一个分支做新任务，互不影响。对我来说，它解决的不是“切分支麻烦”，而是“切分支会打断进行中的任务”。

---

# 附录建议

* 常用命令速查（只放 6 条）

  * `git worktree add -b <branch> <path>`
  * `git worktree list`
  * `git worktree remove <path>`
  * `git worktree prune`
  * `git branch -d/-D <branch>`
* 常见坑：

  * 端口冲突（两个 worktree 同时跑 dev server）
  * 构建输出目录共享导致互相覆盖（把输出放到各自目录）


